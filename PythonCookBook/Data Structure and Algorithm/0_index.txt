資料結構與演算法

問題：
解法：
討論：

1.1 將一個序列拆分給個別變數
問題：
有一個Ｎ個元素的元組(tuple)或序列(sequen),拆分給Ｎ個變數
解法：
賦值(assignment operation) 拆分給變數
討論：
拆分(unpacking)可用在任何可迭代物件(iterable)：元組 串列 字串 檔案 迭代器(iterators) 產生器(generators)
用了就丟的變數名稱(throwaway variable name)：_，須確保所挑的名稱沒用在其他地方

1.2 拆解一個任意長度的可迭代物件之元素
問題：
解開一個可迭代物件(iterable)取出Ｎ個元素，但這個可疊愛物件的長度可能比Ｎ個元素還多，導致「要拆解的值太多(too many values to unpack)」的例外
解法：
星號運算式(star expressions)
討論：
延伸式的可迭代物件(extended iterable unpacking)動作專門用來拆解任意長度或長度未知的可迭代物件(iterables)

1.3 留下最後Ｎ個項目
問題：
在迭代(iteration)或某種處理動作的過程中留下最近項目的少量歷程紀錄(limited history)
解法：
collections.deque適合用來製作這種少量的歷程紀錄。
討論：
搜尋特定項目(items)時，通常使用yield的產生器函示(generator function)

1.4 找出最大或最小的Ｎ個項目
問題：
找出一個群集(collection)中最大或最小的Ｎ個項目做成一個串列(list)
解法：
heapq模組 nlargest() nsmallest()
討論：
heapq運作方式：先將資料轉為一個串列，項目以堆積(heap)的形式安置的。
若找單一最大最小 使用max() min()
若Ｎ的大小接近該群集 使用sorted(items)[:N] sorted(item)[-N:]

1.5 實作一個優先序佇列
問題：
實作一個佇列(queue)，依據給定的優先序(priority)排序項目，每次取出(pop)都回傳最高優先序的項目
解法：
用heapq模組實作簡單的優先序佇列
討論：
heapq.heappush() 插入項目
heapq.heappop() 回傳那個最小的項目
佇列由(-priority, index, item)這種形式的元組(tuples)，取負的priority使項目從最高優先序排到最低優先序
Item實體(instances)是無法比較。
(priority, item)元組，可比較，若有相同優先序就會無法比較。
(priority, index, item)可以比較且因元組不會有相同的index，不會有無法比較的問題。
若要將此佇列用在執行緒(threads)之間的通訊，得加入適當的鎖定(locking)與訊號(signaling)機制。

1.6 在一個字典中將鍵值映射至多個值
問題：
製作一個字典，將各個鍵值(keys)映射到一個以上的值(multidict)
解法：
將值使用串列或集合儲存。
串列：保留插入順序
集合：移除重複項目
可使用collections模組中的defaultdict：自動初始化第一個值，可專注在值的新增。會自動建立字典條目(dictionary entries)
若不想要自動建立字典條目，可使用setdefult()
討論：
使程式碼更簡潔

1.7 維持字典的秩序
問題：
建立一個字典(dictionary)，且在迭代(iterating)或序列化(serializing)時，控制其中項目的次序。
解法：
collection模組的OrderedDict:在迭代時完全保留資料插入順序。
若想精準控制JSON編碼中欄位出現的順序，可先建立一個裝有資料的OrderedDict。
討論：
OrderedDict在內部維護一個雙向鏈結串列(doubly linked list)，依照插入的次序來安排鍵值的次序。
一個OrderedDict的大小超過一個正常字典的兩倍大，因創建了額外的鏈結串列。

1.8 以字典進行運算
問題：
在一個資料字典(dictionary)，進行各種運算。
解法：
使用zip()反轉(invert)這個鍵值的keys與values。
使用zip()搭配sorted()進行排序。
注意：zip()建立一個只能消耗一次的迭代器(iterator)
討論：
若在字典進行常見的資料縮簡(data reductions)，只會處理鍵值(keys)。
zip()反轉成(values,keys)的序列，先比較value，若剛好有一樣的值，會比較鍵值(key)。

1.9 找出兩個字典的共通處
問題：
找出兩個字典共通的鍵值(keys)、值(values)
解法：
使用keys()或item()做簡單的集合運算(set operations)，這類運算也這類運算也可用來更動或過濾字典的內容。
討論：
一個字典就是一個鍵值(key)集合與一個值(value)集合之間的映射(mapping)。
字典的keys()會回傳一個揭露這些鍵值的keys-view物件。這些物件支援集合運算。
字典的items()會回傳一個items-view物件，由(key, value)對組構成。這些物件支援集合運算。
字典的values()不支援集合運算。原因：values-view 值不保證唯一，使得某些集合運算失去功用。

1.10 從一個序列中移除重複的項目並維持原有順序
問題：
消除一個序列(sequence)中重複的值(duplicate values)，但保留剩下項目的次序
解法：
若序列中的值事可雜湊的(hashable)，可使用一個集合(set)一個產生器(generator)解決。
若序列中的值是不可雜湊(unhashable)例如：dict，使用key引數指定一個能把序列項目轉為hashable型別的函式，使可偵測重複的值。
討論：
若只是想消除重複的項目，通常使用set即可解決，但此方式不表保留順序。
此訣竅使用一個產生器函式(generator function)，表示此函式非常通用。
舉例：讀取檔案並消除重複行。

此處key函式模仿類似功能的內建函式：sorted()、min()、max()。相關實例：1.8，1.13

1.11 為一個切片(Slice)命名
問題：

解法：
討論：