資料結構與演算法

問題：
解法：
討論：

1.1 將一個序列拆分給個別變數
問題：
有一個Ｎ個元素的元組(tuple)或序列(sequen),拆分給Ｎ個變數
解法：
賦值(assignment operation) 拆分給變數
討論：
拆分(unpacking)可用在任何可迭代物件(iterable)：元組 串列 字串 檔案 迭代器(iterators) 產生器(generators)
用了就丟的變數名稱(throwaway variable name)：_，須確保所挑的名稱沒用在其他地方

1.2 拆解一個任意長度的可迭代物件之元素
問題：
解開一個可迭代物件(iterable)取出Ｎ個元素，但這個可疊愛物件的長度可能比Ｎ個元素還多，導致「要拆解的值太多(too many values to unpack)」的例外
解法：
星號運算式(star expressions)
討論：
延伸式的可迭代物件(extended iterable unpacking)動作專門用來拆解任意長度或長度未知的可迭代物件(iterables)

1.3 留下最後Ｎ個項目
問題：
在迭代(iteration)或某種處理動作的過程中留下最近項目的少量歷程紀錄(limited history)
解法：
collections.deque適合用來製作這種少量的歷程紀錄。
討論：
搜尋特定項目(items)時，通常使用yield的產生器函示(generator function)

1.4 找出最大或最小的Ｎ個項目
問題：
找出一個群集(collection)中最大或最小的Ｎ個項目做成一個串列(list)
解法：
heapq模組 nlargest() nsmallest()
討論：
heapq運作方式：先將資料轉為一個串列，項目以堆積(heap)的形式安置的。
若找單一最大最小 使用max() min()
若Ｎ的大小接近該群集 使用sorted(items)[:N] sorted(item)[-N:]

1.5 實作一個優先序佇列
問題：
實作一個佇列(queue)，依據給定的優先序(priority)排序項目，每次取出(pop)都回傳最高優先序的項目
解法：
用heapq模組實作簡單的優先序佇列
討論：
heapq.heappush() 插入項目
heapq.heappop() 回傳那個最小的項目
佇列由(-priority, index, item)這種形式的元組(tuples)，取負的priority使項目從最高優先序排到最低優先序
Item實體(instances)是無法比較。
(priority, item)元組，可比較，若有相同優先序就會無法比較。
(priority, index, item)可以比較且因元組不會有相同的index，不會有無法比較的問題。
若要將此佇列用在執行緒(threads)之間的通訊，得加入適當的鎖定(locking)與訊號(signaling)機制。

1.6 在一個字典中將鍵值映射至多個值
問題：
製作一個字典，將各個鍵值(keys)映射到一個以上的值(multidict)
解法：
將值使用串列或集合儲存。
串列：保留插入順序
集合：移除重複項目
可使用collections模組中的defaultdict：自動初始化第一個值，可專注在值的新增。會自動建立字典條目(dictionary entries)
若不想要自動建立字典條目，可使用setdefult()
討論：
使程式碼更簡潔
